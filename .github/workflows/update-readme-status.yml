name: Update README Submission Table

on:
  workflow_dispatch: {}
  schedule:
    - cron: "15 5 * * *"   # daily 05:15 UTC

permissions:
  contents: write

concurrency:
  group: update-readme-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build-table:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Generate table from issues
        id: gen
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // 1) Locate or scaffold README (accept common casings)
            const candidates = ['README.md','README.MD','readme.md'];
            let readmePath = candidates.find(p => fs.existsSync(p));
            if (!readmePath) {
              readmePath = 'README.md';
              const scaffold = [
                '# ðŸŽ“ Course Portfolio â€” <Your Name>',
                '',
                '## âœ… Submission Status (automatically updated)',
                '<!-- STATUS:START -->',
                '| Item | Key | Live | Source | Status | Notes |',
                '|---|---|---|---|---|---|',
                '<!-- STATUS:END -->',
                ''
              ].join('\n');
              fs.writeFileSync(readmePath, scaffold);
              core.info('Created README.md scaffold with STATUS markers.');
            }

            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            // 2) Get ALL issues (open+closed), filter in code
            const allIssues = await github.paginate(
              github.rest.issues.listForRepo,
              { owner, repo, state: 'all', per_page: 100 }
            );

            // Helper functions
            const statusOrder = [
              'changes-requested','blocked',
              'peer-review-requested','reviewed','ready-for-approval',
              'completed','approved','deployed'
            ];

            const pickStatus = (labels) => {
              const names = labels.map(l => (l.name || l).toString());
              for (const s of statusOrder) if (names.includes(s)) return s;
              return '';
            };

            const findKey = (labels) => {
              const names = labels.map(l => (l.name || l).toString());
              return names.find(n => /^(lab|project|capstone)-\d+$/i.test(n)) || '';
            };

            const typeOf = (labels) => {
              const names = labels.map(l => (l.name || l).toString());
              if (names.includes('lab')) return 'lab';
              if (names.includes('project')) return 'project';
              if (names.includes('capstone')) return 'capstone';
              return '';
            };

            // Roadmap items = have a key AND label 'task' (or legacy 'assignment')
            const items = allIssues.filter(it => {
              const key = findKey(it.labels);
              if (!key) return false;
              const names = it.labels.map(l => (l.name || l).toString());
              return names.includes('task') || names.includes('assignment');
            });

            core.info(`Found ${items.length} roadmap issue(s) with key + task/assignment.`);

            // 3) Build rows
            const baseLive = `https://${owner}.github.io/${repo}`;
            const rows = items.map(it => {
              const key = findKey(it.labels);
              const typ = typeOf(it.labels);
              const title = it.title;

              let live = '', source = '';
              if (typ === 'lab') {
                live   = `${baseLive}/labs/${key}/`;
                source = `/labs/${key}/`;
              } else if (typ === 'project') {
                live   = `${baseLive}/projects/${key}/`;
                source = `/projects/${key}/`;
              } else if (typ === 'capstone') {
                live   = '(n/a)';
                source = `/capstone/${key}/`;
              }

              const status = pickStatus(it.labels);
              return { title, key, live, source, status };
            });

            // Sort by type + numeric key
            const norm = k => {
              const m = k.match(/^(lab|project|capstone)-(\d+)/i);
              return m ? `${m[1]}-${String(+m[2]).padStart(3,'0')}` : k;
            };
            rows.sort((a,b) => norm(a.key).localeCompare(norm(b.key)));

            // 4) Build markdown table
            const header = '| Item | Key | Live | Source | Status | Notes |\n|---|---|---|---|---|---|';
            const body = rows.map(r =>
              `| ${r.title} | \`${r.key}\` | ${r.live ? `<${r.live}>` : ''} | \`${r.source}\` | ${r.status || ''} |  |`
            ).join('\n');
            const table = `${header}\n${body}`;

            // 5) Replace between markers
            const start = '<!-- STATUS:START -->';
            const end   = '<!-- STATUS:END -->';
            let readme = fs.readFileSync(readmePath, 'utf8');

            if (!readme.includes(start) || !readme.includes(end)) {
              readme = `${readme.trim()}\n\n## âœ… Submission Status (automatically updated)\n${start}\n${header}\n${end}\n`;
            }

            const re = new RegExp(`${start}[\\s\\S]*?${end}`);
            const updated = readme.replace(re, `${start}\n${table}\n${end}`);

            if (updated !== readme) {
              fs.writeFileSync(readmePath, updated);
              core.setOutput('changed', 'true');
              core.setOutput('path', readmePath);
              core.info(`Updated table with ${rows.length} row(s).`);
            } else {
              core.setOutput('changed', 'false');
              core.info('No README changes detected (table identical).');
            }

      - name: Commit README if changed
        if: steps.gen.outputs.changed == 'true'
        uses: EndBug/add-and-commit@v9
        with:
          add: ${{ steps.gen.outputs.path || 'README.md' }}
          message: "docs: auto-update submission table from issues"
